<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello,World!</title>
    <url>/2022/05/12/21-48-48/</url>
    <content><![CDATA[<p>​       搭建了一晚上，终于完成了博客的搭建，第一篇总得起个好名字吧。想了很久还是叫做“Hello,World”吧，我想对于每个程序员来说搭载好每一个新环境的测试都会是“Hello,World”。</p>
<p>​       从吴军的《浪潮之巅》中得知，“Hello,World”最早诞生于贝尔实验室，你可能对这个实验室的名字感到陌生，新一轮技术革命的核心——集成电路、Linux操作系统的前身Unix、编程始祖且长久未衰的C语言、卫星电话……全部出自贝尔实验室。包括我们熟知的Intel、AMD等芯片巨头都与这家实验室有着千丝万缕的联系。毫不夸张的说，贝尔实验室创造了现代科技的半壁江山。有谁能想到就是一家起初做电话的公司发展到拥有史上最牛实验室的科技帝国，又有谁能想到时至今日那个诞生过13名诺奖得主的实验室已沦落成为一个平平无奇的研究机构，更无人能想到主宰下一个百年的技术在何方……</p>
<p>​       这就是这个时代，冷酷，但有情。</p>
<p>​       “Hello，World”，世界你好，世界很好，世界变得更好！</p>
]]></content>
      <categories>
        <category>发展</category>
      </categories>
      <tags>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
  <entry>
    <title>实验一 进程的建立</title>
    <url>/2022/05/12/23-19-37/</url>
    <content><![CDATA[<h2 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h2><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>​     创建两个进程，让子进程读取一个文件，父进程等待子进程读取 完文件后继续执行，实现进程协同工作。进程协同工作就是协调好两个进程，使之安排好先后次序并以此执行，可以用等待函数来实现这一点。当需要等待子进程运行结束 时，可在父进程中调用等待函数。</p>
<h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">  <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(fpid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fpid==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：我是子进程,id=%d，开始读取文件：\n&quot;</span>,getpid());</span><br><span class="line">   FILE *fp=fopen(<span class="string">&quot;test1file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);    <span class="comment">//定义文件流</span></span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> text[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">while</span> (fgets(text,<span class="number">2000</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">puts</span>(text);   <span class="comment">//输出文件内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：读取文件结束\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：我是父进程id=%d ,我要等待子进程\n&quot;</span>,getpid());</span><br><span class="line">               </span><br><span class="line">   <span class="type">int</span> ret = waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程 已经结束，ret=%d\n&quot;</span>, ret);</span><br><span class="line">   	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="程序简要分析"><a href="#程序简要分析" class="headerlink" title="程序简要分析"></a>程序简要分析</h4><p>​    该程序主要使用了fork()函数创建了子进程，然后让子进程读取文件并输出文件内容，同时父进程等待子进程的执行，这里用到了waitpid()函数。等待子进程运行完成后，父进程继续运行。</p>
<p>主要函数：pid_t fork(void)</p>
<p>​      pid_t waitpid(pid_t pid,int * status,int options）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>上机实验</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>魔王语言解释</title>
    <url>/2022/05/13/17-39-53/</url>
    <content><![CDATA[<p>问题输入<br>一组数据，数据为一个字符串，表示一个待翻译的字符串。<br>问题输出<br>将字符串按规则翻译后输出。<br>输入样例<br>B(pxyzABhij)B<br>输出样例<br>tsaedsaepjpiphptsaedsaepsaepzpypxptsaedsae</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> *base;</span><br><span class="line">	<span class="type">char</span> *top;</span><br><span class="line">	<span class="type">int</span> size; </span><br><span class="line">&#125;sqStack;   </span><br><span class="line"><span class="comment">//构造栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">	S-&gt;base=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*maxsize);</span><br><span class="line">	<span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	S-&gt;size=maxsize;</span><br><span class="line">	S-&gt;top=S-&gt;base;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;top==S-&gt;base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> *c=*--S-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">	*S-&gt;top++=c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">LNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	LNode next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	LNode front;  <span class="comment">//队头指针 </span></span><br><span class="line">	LNode rear;   <span class="comment">//队尾指针 </span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//构造队列 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span>&#123;</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">	Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PushQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">	LNode p=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">	p-&gt;data=c;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear-&gt;next=p;</span><br><span class="line">	Q-&gt;rear=p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   LNode p=Q-&gt;front-&gt;next;</span><br><span class="line">   *c=p-&gt;data;</span><br><span class="line">   Q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==p) Q-&gt;rear=Q-&gt;front;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> st[<span class="number">1000</span>],a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">	<span class="comment">//puts(st);</span></span><br><span class="line">	sqStack S1,S2;</span><br><span class="line">	LinkQueue L;</span><br><span class="line">	InitQueue(&amp;L);</span><br><span class="line">	InitStack(&amp;S1);</span><br><span class="line">	InitStack(&amp;S2);</span><br><span class="line">	<span class="comment">//将字符串从右向左依次入栈 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(<span class="built_in">strlen</span>(st)<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		Push(&amp;S1,st[i]);</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//处理括号内容 </span></span><br><span class="line">	<span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">		<span class="type">char</span> r;</span><br><span class="line">		GetTop(&amp;S1,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(r!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			Push(&amp;S2,r);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="type">char</span> C;</span><br><span class="line">			GetTop(&amp;S2,&amp;a);</span><br><span class="line">			<span class="keyword">while</span>(a!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				PushQueue(&amp;L,a);</span><br><span class="line">				C=a;</span><br><span class="line">				GetTop(&amp;S2,&amp;a);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(L.front-&gt;next!=L.rear)&#123;</span><br><span class="line">				<span class="type">char</span> b;</span><br><span class="line">				GetQueue(&amp;L,&amp;b);</span><br><span class="line">				Push(&amp;S2,C);</span><br><span class="line">				Push(&amp;S2,b);</span><br><span class="line">			&#125;</span><br><span class="line">			Push(&amp;S2,C);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//B和A转化</span></span><br><span class="line">	<span class="keyword">while</span>(S2.base!=S2.top)&#123;</span><br><span class="line">		<span class="type">char</span> n;</span><br><span class="line">		<span class="type">char</span> A[<span class="number">4</span>]=<span class="string">&quot;sae&quot;</span>;</span><br><span class="line">		<span class="type">char</span> B[<span class="number">9</span>]=<span class="string">&quot;tsaedsae&quot;</span>;</span><br><span class="line">		GetTop(&amp;S2,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;n!=<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			Push(&amp;S1,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				Push(&amp;S1,A[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				Push(&amp;S1,B[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">char</span> m;</span><br><span class="line">	<span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">		GetTop(&amp;S1,&amp;m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是考察栈和队列，建议画图解决。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫问题</title>
    <url>/2022/05/13/17-51-40/</url>
    <content><![CDATA[<h3 id="问题输入"><a href="#问题输入" class="headerlink" title="问题输入"></a>问题输入</h3><p>一组数据，输入数据第1行为两个正整数m和n，m表示迷宫高度，n表示迷宫宽度，m&lt;100,n&lt;100；第2行为两个整数，分表表示起点的行列位置；第3为两个整数，分别表示终点的行列位置；其后为m行数据，每行n个整数，表示迷宫对应位置的状态，0表示通路，1表示障碍。 </p>
<h3 id="问题输出"><a href="#问题输出" class="headerlink" title="问题输出"></a>问题输出</h3><p>以三元组形式（见P105）输出从起点到终点搜索到的第一条通路，没有则输出no </p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>8 8</p>
<p>1 1</p>
<p>8 8</p>
<p>0 0 1 0 0 0 1 0</p>
<p>0 0 1 1 0 0 1 0 </p>
<p>0 0 0 0 1 1 0 0</p>
<p>0 1 1 1 0 0 0 0</p>
<p>0 0 0 1 1 0 0 0</p>
<p>0 1 0 0 0 1 0 0</p>
<p>0 1 1 1 0 1 1 0</p>
<p>1 1 0 0 0 0 0 0</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>(1,1,1),(1,2,2),(2,2,2),(3,2,3),(3,1,2),(4,1,2),(5,1,1),(5,2,1),(5,3,2),(6,3,1),(6,4,1),(6,5,2),(7,5,2),(8,5,1),(8,6,1),(8,7,1),(8,8,1) </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> **<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> di;</span><br><span class="line">&#125;seat;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	seat *base;</span><br><span class="line">	seat *top;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;sqStack;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">	S-&gt;base=(seat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seat)*Maxsize);</span><br><span class="line">	<span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	S-&gt;size=Maxsize;</span><br><span class="line">	S-&gt;top=S-&gt;base;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,seat a)</span>&#123;</span><br><span class="line">	*S-&gt;top++=a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,seat *a)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;base==S-&gt;top) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> *a=*--S-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Map</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="built_in">map</span>=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">		<span class="built_in">map</span>[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">	   <span class="built_in">map</span>[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	   <span class="built_in">map</span>[i][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line">		<span class="built_in">map</span>[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[x<span class="number">-1</span>][j]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;y<span class="number">-1</span>;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findPath</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span>&#123;</span><br><span class="line">	sqStack q;</span><br><span class="line">	InitStack(&amp;q);</span><br><span class="line">	seat a,b,c;</span><br><span class="line">	<span class="type">int</span> d,m,n,f;</span><br><span class="line">	a.x=x1;</span><br><span class="line">	a.y=y1;</span><br><span class="line">	<span class="built_in">map</span>[x1][y1]=<span class="number">-1</span>;</span><br><span class="line">	a.di=<span class="number">0</span>;</span><br><span class="line">	Push(&amp;q,a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q.top!=q.base)&#123;</span><br><span class="line">		<span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2) <span class="keyword">break</span>;</span><br><span class="line">		d=(q.top<span class="number">-1</span>)-&gt;di;</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(d&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">            d++;</span><br><span class="line">			<span class="keyword">switch</span>(d)&#123;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">1</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y+<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">2</span>: m=(q.top<span class="number">-1</span>)-&gt;x+<span class="number">1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">3</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y<span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">4</span>: m=(q.top<span class="number">-1</span>)-&gt;x<span class="number">-1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">			  	&#125;	</span><br><span class="line">			  <span class="keyword">if</span>(<span class="built_in">map</span>[m][n]==<span class="number">0</span>)&#123;</span><br><span class="line">			  	<span class="built_in">map</span>[m][n]=<span class="number">-1</span>;</span><br><span class="line">			  	(q.top<span class="number">-1</span>)-&gt;di=d;</span><br><span class="line">			  	b.x=m;</span><br><span class="line">			  	b.y=n;</span><br><span class="line">			  	b.di=<span class="number">0</span>;</span><br><span class="line">			  	Push(&amp;q,b);</span><br><span class="line">			  	f=<span class="number">1</span>;</span><br><span class="line">			  	<span class="keyword">break</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">			GetTop(&amp;q,&amp;c);</span><br><span class="line">			<span class="built_in">map</span>[c.x][c.y]=<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2)&#123;</span><br><span class="line">		<span class="keyword">for</span>(seat *i=q.base;i&lt;(q.top<span class="number">-1</span>);i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d),&quot;</span>,i-&gt;x,i-&gt;y,i-&gt;di);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d)&quot;</span>,(q.top<span class="number">-1</span>)-&gt;x,(q.top<span class="number">-1</span>)-&gt;y,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> X,Y,ax,ay,bx,by;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;X,&amp;Y,&amp;ax,&amp;ay,&amp;bx,&amp;by);</span><br><span class="line">	Map(X+<span class="number">2</span>,Y+<span class="number">2</span>); <span class="comment">//初始化迷宫，把迷宫四周围上1；</span></span><br><span class="line">	findPath(ax,ay,bx,by);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Intel时代</title>
    <url>/2022/05/13/22-40-51/</url>
    <content><![CDATA[<p>​    之所以要写Intel，是因为近日计组课涉及了指令集的内容，就忽然想到了《浪潮之巅》中对Intel的介绍。如果你有读过《浪潮之巅》，那么你没有必要浪费时间阅读这篇关于Intel的介绍，因为这篇介绍的大部分内容在这本书中都包含。如果你没有读过，那么也强烈希望你能在读完这篇介绍后阅读一下这本书，尤其是计算机从业者。</p>
<h3 id="历史必然选择"><a href="#历史必然选择" class="headerlink" title="历史必然选择"></a>历史必然选择</h3><p>​    1968年摩尔和诺伊斯创办了英特尔公司，就是提出摩尔定律（每18个月集成电路复杂度会翻倍，有机会再细讲）的那个男人。起初的英特尔只是一个小婴儿，因为IBM（当时最大的计算机厂商之一）等计算机制造公司都是自己设计处理器，而英特尔设计的都是一些低端的微型处理器。70年代末，英特尔设计出了处理器8086.</p>
<p>​    由于IBM公司当时为了与苹果快速抢占个人计算机（PC）市场，就索性直接采用了英特尔的8086，这一用直接奠定了英特尔的“不可撼动”的地位。原因就是IBM的PC机销售远超预期。之后兼容机（其实就是组装机啦）由于价格低廉也有不错的销量，而这些兼容机毫无疑问必须选择8086处理器和Windows才能实现兼容的目的。所以时至今日，IBM已经不再生产PC，但是英特尔和微软的地位无法撼动。</p>
<p>​    再后来，英特尔也走上了高端路线，设计了奔腾系、酷睿系、牙膏系（狗头）……</p>
<h3 id="指令集的战争"><a href="#指令集的战争" class="headerlink" title="指令集的战争"></a>指令集的战争</h3><p>​    这部分才是这篇想主要介绍的东西，可以作为课程知识的背景。</p>
<p>​    先简要了解一下什么是指令集：就是CPU中用来计算和控制计算机系统的一套指令的集合。再了解一下两大指令集CISC（复杂指令集）和RISC（精简指令集）的区别，来自计组课本：</p>
<ol>
<li><p>指令系统 CISC数量多，复杂；RISC数量少，精简。</p>
</li>
<li><p>使用频率 CISC相差大；RISC 接近。毕竟RISC就是选取了使用频率高的指令。</p>
</li>
<li><p>CUP功耗 CISC高；RISC低。</p>
<p>……</p>
</li>
</ol>
<p>​    简单对比后就算你不知道什么是指令集你也一定会说RISC比较好。那么恭喜你和当时众多学者想法一样，未来将是RISC的天下。<br>​    于是一大堆企业转战RISC，其中包括一些原本只是采购而自己不研发的企业开始自己研发RISC处理器，谁都想在风口上飞起来。英特尔也感受到了危机，但是做出了最正确的选择。英特尔继续坚持自己在基于CISC指令集的CPU上的领先地位，又开始着手RISC指令。之后英特尔开发出来几款RISC产品，但是都不成功。而RISC派这边，基本处于各自为战的状态，群龙无首，做出的机器兼容性可想而知。虽然RISC具有天然的性能优势，但是英特尔已经将自己的CISC优化的非常不错，但是绝大部分消费者在稳定兼容和性能稍稍领先上选择前者。<br>​    这里还有一个小故事，在RISC提出之前。有一家企业可以和英特尔抗衡——摩托罗拉。当时IBM选择了英特尔，而苹果选择了摩托罗拉。但是RISC指令提出后由于摩托罗拉做出了错误的决定再加上管理层问题，丢失了以前的大部分订单，基本上放弃了CISC转战RISC，直到最后一棵稻草苹果也放弃它。<br>​    虽然那个年代的指令集之争英特尔大获全胜，但是新世纪以来，由于智能手机的快速发展，基于ARM架构(采用RISC指令集)的手机处理器也换代发展迅速。当某一架构的硬件性能达到极限时，只能尝试改变，于是最近英特尔也正在进军RISC-V，毕竟RISC具有天然性能优势。</p>
<h3 id="芯片帝国"><a href="#芯片帝国" class="headerlink" title="芯片帝国"></a>芯片帝国</h3><p>​    英特尔毫无疑问已经发展成为了一个芯片帝国，世界上超一半计算机都在采用英特尔芯片。它的成功离不开决策、时机、运气。英特尔历史上唯一的错误决定就是看轻了智能手机时代，将手机芯片拱手相让，错失了一次绝佳良机。现在好似又出现一家看似能和英特尔较量的公司——AMD。但是两者其实根本不在一个水平上，AMD为了抢占英特尔市场也只能跟在英特尔身后做出兼容芯片，起码我们消费者又多了一个非常不错的选择。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>发展</category>
      </categories>
      <tags>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员天花板——雷军</title>
    <url>/2022/05/20/19-46-53/</url>
    <content><![CDATA[<p>​    数码圈流传着这样一句话：“你可以不喜欢小米，但是你没有理由不钦佩雷军”。这位每次出现在大众视野基本都是穿着牛仔裤和衬衫标准”程序员“搭配的”雷布斯“，不仅担任着数家上市公司董事长，还是一位极具前瞻性的天使投资人，已经成为程序员天花板。</p>
<h3 id="“有人说我写的代码-如诗一样优雅”"><a href="#“有人说我写的代码-如诗一样优雅”" class="headerlink" title="“有人说我写的代码 如诗一样优雅”"></a>“有人说我写的代码 如诗一样优雅”</h3><p>​    这句话是雷军在一段访谈中对自己的称赞，作为程序员出身的雷军对自己的编程能力还是蛮自信的，事实究竟如何？有人扒出了一段雷军在1994年写的一段完整的汇编代码贴在了网上，无数网友回复”跪着读完“。这一段高质量的代码就算在今天也少有人能写的出来。</p>
<p>​    1987年雷军进入武汉大学计算机系，他仅使用了两年的时间完成了所有大学内容和毕业设计。大学期间写过的很多代码早已被编入武汉大学的教材……在大学期间他就开始写软件出售来赚取利润。大四那年他开始了人生的第一次创业，仿制金山汉卡。然而他的第一次创业以失败告终，破产清算时仅仅获得了一台电脑。别急，传奇才刚刚开始。</p>
<h3 id="扛起中国软件的大旗——金山"><a href="#扛起中国软件的大旗——金山" class="headerlink" title="扛起中国软件的大旗——金山"></a>扛起中国软件的大旗——金山</h3><p>​    谁也没想到，最初靠仿制金山赚钱的雷军一眼被“中国第一程序员”——求伯君看中，力邀他加入金山，几年的时间内，雷军就从一个新员工成为了金山总裁。当时金山面临的最大对手就是微软，微软的office利用与操作系统捆绑的优势成为后起之秀，抢占了WPS的大部分市场。雷军年少轻狂，带领团队做出了新一代产品”盘古“,里面融合了文字处理、词典、事务管理等多种功能，本想凭借这一产品重回巅峰，但惨淡的销售量给了雷军闷头一棒。</p>
<p>​    这一盆冷水浇得雷军醒不过来，最后他递交了辞职信。但是求伯君极力挽留，只给他休假。半年后，雷军重回岗位，他这次回来显然已经制定好了转型战略，之后新版WPS强势上场，在微软的歼灭战中夹缝生存，重新赢得了不少的市场占有率。</p>
<p>​    直到2007年，金山上市，雷军为这一刻付出了十几年的心血。金山无疑是中国软件的一面旗帜，在遭遇国外产品不公平竞争的时刻依旧逆势而上，并且获得了不菲的成绩！</p>
<h3 id="“所有产品不超过5-的利润”——小米"><a href="#“所有产品不超过5-的利润”——小米" class="headerlink" title="“所有产品不超过5%的利润”——小米"></a>“所有产品不超过5%的利润”——小米</h3><p>​    就在金山上市后两个月，雷军宣布离职，这让很多人不能理解。接下来的时间，雷军开始专注自己的投资事业，同时，雷军似乎拥有感应商业机会的本能，他在等待拥抱一个全新时代的到来——移动互联时代。</p>
<p>​    在iPhone开始风靡全球的同时，他在思考安卓的开放性是不是更具有可玩性。他找到投资人、“同盟者”，向他们描述他大胆的想法。2010年四月，在北京一家小工作室里，十几个人喝了一锅小米粥，小米诞生。</p>
<p>​    2011年，小米第一部手机发布，豪华的配置，1999的价格，赢得了一众好评，出现了一机难求的场面。2013年，红米首款手机发布，以极低的价格终结了山寨机泛滥的市场。</p>
<p>​    2019年，小米成为了世界最年轻的500强，并且具有了完整的生态链体系。</p>
<p>​    如今，雷军已经开启了自己人生的最后一次伟大创业——小米汽车，我们无法预测结果如何，但可以肯定的是雷军早已成为中国科技界的“传奇”！这位向往纯粹技术的工程师在为实现“科技走进千家万户”而努力。</p>
<h4 id="因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛"><a href="#因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛" class="headerlink" title="因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛"></a>因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛</h4><p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>发展</category>
      </categories>
      <tags>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
</search>
