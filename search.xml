<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Intel时代</title>
      <link href="/2022/05/13/22-40-51/"/>
      <url>/2022/05/13/22-40-51/</url>
      
        <content type="html"><![CDATA[<p>​    之所以要写Intel，是因为近日计组课涉及了指令集的内容，就忽然想到了《浪潮之巅》中对Intel的介绍。如果你有读过《浪潮之巅》，那么你没有必要浪费事件阅读这篇关于Intel的介绍，因为这篇介绍的大部分内容在这本书中都包含。如果你没有读过，那么也强烈希望你能在读完这篇介绍后阅读一下这本书，尤其是计算机从业者。</p><h3 id="历史必然选择"><a href="#历史必然选择" class="headerlink" title="历史必然选择"></a>历史必然选择</h3><p>​    1968年摩尔和诺伊斯创办了英特尔公司，就是提出摩尔定律（每18个月集成电路复杂度会翻倍，有机会再细讲）的那个男人。起初的英特尔只是一个小婴儿，因为IBM（当时最大的计算机厂商之一）等计算机制造公司都是自己设计处理器，而英特尔设计的都是一些低端的微型处理器。70年代末，英特尔设计出了处理器8086.</p><p>​    由于IBM公司当时为了与苹果快速抢占个人计算机（PC）市场，就索性直接采用了英特尔的8086，这一用直接奠定了英特尔的“不可撼动”的地位。原因就是IBM的PC机销售远超预期。之后兼容机（其实就是组装机啦）由于价格低廉也有不错的销量，而这些兼容机毫无疑问必须选择8086处理器和Windows才能实现兼容的目的。所以时至今日，IBM已经不再生产PC，但是英特尔和微软的地位无法撼动。</p><p>​    再后来，英特尔也走上了高端路线，设计了奔腾系、酷睿系、牙膏系（狗头）……</p><h3 id="指令集的战争"><a href="#指令集的战争" class="headerlink" title="指令集的战争"></a>指令集的战争</h3><p>​    这部分才是这篇想主要介绍的东西，可以作为课程知识的背景。</p><p>​    先简要了解一下什么是指令集：就是CPU中用来计算和控制计算机系统的一套指令的集合。再了解一下两大指令集CISC（复杂指令集）和RISC（精简指令集）的区别，来自计组课本：</p><ol><li><p>指令系统 CISC数量多，复杂；RISC数量少，精简。</p></li><li><p>使用频率 CISC相差大；RISC 接近。毕竟RISC就是选取了使用频率高的指令。</p></li><li><p>CUP功耗 CISC高；RISC低。</p><p>……</p></li></ol><p>​    简单对比后就算你不知道什么是指令集你也一定会说RISC比较好。那么恭喜你和当时众多学者想法一样，未来将是RISC的天下。<br>​    于是一大堆企业转战RISC，其中包括一些原本只是采购而自己不研发的企业开始自己研发RISC处理器，谁都想在风口上飞起来。英特尔也感受到了危机，但是做出了最正确的选择。英特尔继续坚持自己在基于CISC指令集的CPU上的领先地位，又开始着手RISC指令。之后英特尔开发出来几款RISC产品，但是都不成功。而RISC派这边，基本处于各自为战的状态，群龙无首，做出的机器兼容性可想而知。虽然RISC具有天然的性能优势，但是英特尔已经将自己的CISC优化的非常不错，但是绝大部分消费者在稳定兼容和性能稍稍领先上选择前者。<br>​    这里还有一个小故事，在RISC提出之前。有一家企业可以和英特尔抗衡——摩托罗拉。当时IBM选择了英特尔，而苹果选择了摩托罗拉。但是RISC指令提出后由于摩托罗拉做出了错误的决定再加上管理层问题，丢失了以前的大部分订单，基本上放弃了CISC转战RISC，直到最后一棵稻草苹果也放弃它。<br>​    虽然那个年代的指令集之争英特尔大获全胜，但是新世纪以来，由于智能手机的快速发展，基于ARM架构(采用RISC指令集)的手机处理器也换代发展迅速。当某一架构的硬件性能达到极限时，只能尝试改变，于是最近英特尔也正在进军RISC-V，毕竟RISC具有天然性能优势。</p><h3 id="芯片帝国"><a href="#芯片帝国" class="headerlink" title="芯片帝国"></a>芯片帝国</h3><p>​    英特尔毫无疑问已经发展成为了一个芯片帝国，世界上超一半计算机都在采用英特尔芯片。它的成功离不开决策、时机、运气。英特尔历史上唯一的错误决定就是看轻了智能手机时代，将手机芯片拱手相让，错失了一次绝佳良机。现在好似又出现一家看似能和英特尔较量的公司——AMD。但是两者其实根本不在一个水平上，AMD为了抢占英特尔市场也只能跟在英特尔身后做出兼容芯片，起码我们消费者又多了一个非常不错的选择。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《浪潮之巅》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫问题</title>
      <link href="/2022/05/13/17-51-40/"/>
      <url>/2022/05/13/17-51-40/</url>
      
        <content type="html"><![CDATA[<h3 id="问题输入"><a href="#问题输入" class="headerlink" title="问题输入"></a>问题输入</h3><p>一组数据，输入数据第1行为两个正整数m和n，m表示迷宫高度，n表示迷宫宽度，m&lt;100,n&lt;100；第2行为两个整数，分表表示起点的行列位置；第3为两个整数，分别表示终点的行列位置；其后为m行数据，每行n个整数，表示迷宫对应位置的状态，0表示通路，1表示障碍。 </p><h3 id="问题输出"><a href="#问题输出" class="headerlink" title="问题输出"></a>问题输出</h3><p>以三元组形式（见P105）输出从起点到终点搜索到的第一条通路，没有则输出no </p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>8 8</p><p>1 1</p><p>8 8</p><p>0 0 1 0 0 0 1 0</p><p>0 0 1 1 0 0 1 0 </p><p>0 0 0 0 1 1 0 0</p><p>0 1 1 1 0 0 0 0</p><p>0 0 0 1 1 0 0 0</p><p>0 1 0 0 0 1 0 0</p><p>0 1 1 1 0 1 1 0</p><p>1 1 0 0 0 0 0 0</p><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>(1,1,1),(1,2,2),(2,2,2),(3,2,3),(3,1,2),(4,1,2),(5,1,1),(5,2,1),(5,3,2),(6,3,1),(6,4,1),(6,5,2),(7,5,2),(8,5,1),(8,6,1),(8,7,1),(8,8,1) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> **<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> di;</span><br><span class="line">&#125;seat;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">seat *base;</span><br><span class="line">seat *top;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;sqStack;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">S-&gt;base=(seat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seat)*Maxsize);</span><br><span class="line"><span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">S-&gt;size=Maxsize;</span><br><span class="line">S-&gt;top=S-&gt;base;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,seat a)</span>&#123;</span><br><span class="line">*S-&gt;top++=a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,seat *a)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;base==S-&gt;top) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> *a=*--S-&gt;top;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Map</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line"><span class="built_in">map</span>=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line"><span class="built_in">map</span>[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">   <span class="built_in">map</span>[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">map</span>[i][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line"><span class="built_in">map</span>[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">map</span>[x<span class="number">-1</span>][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;y<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findPath</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span>&#123;</span><br><span class="line">sqStack q;</span><br><span class="line">InitStack(&amp;q);</span><br><span class="line">seat a,b,c;</span><br><span class="line"><span class="type">int</span> d,m,n,f;</span><br><span class="line">a.x=x1;</span><br><span class="line">a.y=y1;</span><br><span class="line"><span class="built_in">map</span>[x1][y1]=<span class="number">-1</span>;</span><br><span class="line">a.di=<span class="number">0</span>;</span><br><span class="line">Push(&amp;q,a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q.top!=q.base)&#123;</span><br><span class="line"><span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2) <span class="keyword">break</span>;</span><br><span class="line">d=(q.top<span class="number">-1</span>)-&gt;di;</span><br><span class="line">f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(d&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">            d++;</span><br><span class="line"><span class="keyword">switch</span>(d)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y+<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: m=(q.top<span class="number">-1</span>)-&gt;x+<span class="number">1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y<span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: m=(q.top<span class="number">-1</span>)-&gt;x<span class="number">-1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">map</span>[m][n]==<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">map</span>[m][n]=<span class="number">-1</span>;</span><br><span class="line">  (q.top<span class="number">-1</span>)-&gt;di=d;</span><br><span class="line">  b.x=m;</span><br><span class="line">  b.y=n;</span><br><span class="line">  b.di=<span class="number">0</span>;</span><br><span class="line">  Push(&amp;q,b);</span><br><span class="line">  f=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">GetTop(&amp;q,&amp;c);</span><br><span class="line"><span class="built_in">map</span>[c.x][c.y]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2)&#123;</span><br><span class="line"><span class="keyword">for</span>(seat *i=q.base;i&lt;(q.top<span class="number">-1</span>);i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d),&quot;</span>,i-&gt;x,i-&gt;y,i-&gt;di);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d)&quot;</span>,(q.top<span class="number">-1</span>)-&gt;x,(q.top<span class="number">-1</span>)-&gt;y,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> X,Y,ax,ay,bx,by;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;X,&amp;Y,&amp;ax,&amp;ay,&amp;bx,&amp;by);</span><br><span class="line">Map(X+<span class="number">2</span>,Y+<span class="number">2</span>); <span class="comment">//初始化迷宫，把迷宫四周围上1；</span></span><br><span class="line">findPath(ax,ay,bx,by);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔王语言解释</title>
      <link href="/2022/05/13/17-39-53/"/>
      <url>/2022/05/13/17-39-53/</url>
      
        <content type="html"><![CDATA[<p>问题输入<br>一组数据，数据为一个字符串，表示一个待翻译的字符串。<br>问题输出<br>将字符串按规则翻译后输出。<br>输入样例<br>B(pxyzABhij)B<br>输出样例<br>tsaedsaepjpiphptsaedsaepsaepzpypxptsaedsae</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> *base;</span><br><span class="line"><span class="type">char</span> *top;</span><br><span class="line"><span class="type">int</span> size; </span><br><span class="line">&#125;sqStack;   </span><br><span class="line"><span class="comment">//构造栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">S-&gt;base=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*maxsize);</span><br><span class="line"><span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">S-&gt;size=maxsize;</span><br><span class="line">S-&gt;top=S-&gt;base;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;top==S-&gt;base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> *c=*--S-&gt;top;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">*S-&gt;top++=c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">LNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">LNode next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">LNode front;  <span class="comment">//队头指针 </span></span><br><span class="line">LNode rear;   <span class="comment">//队尾指针 </span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//构造队列 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span>&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PushQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">LNode p=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">p-&gt;data=c;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next=p;</span><br><span class="line">Q-&gt;rear=p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   LNode p=Q-&gt;front-&gt;next;</span><br><span class="line">   *c=p-&gt;data;</span><br><span class="line">   Q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==p) Q-&gt;rear=Q-&gt;front;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> st[<span class="number">1000</span>],a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line"><span class="comment">//puts(st);</span></span><br><span class="line">sqStack S1,S2;</span><br><span class="line">LinkQueue L;</span><br><span class="line">InitQueue(&amp;L);</span><br><span class="line">InitStack(&amp;S1);</span><br><span class="line">InitStack(&amp;S2);</span><br><span class="line"><span class="comment">//将字符串从右向左依次入栈 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=(<span class="built_in">strlen</span>(st)<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">Push(&amp;S1,st[i]);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//处理括号内容 </span></span><br><span class="line"><span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line"><span class="type">char</span> r;</span><br><span class="line">GetTop(&amp;S1,&amp;r);</span><br><span class="line"><span class="keyword">if</span>(r!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">Push(&amp;S2,r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line"><span class="type">char</span> C;</span><br><span class="line">GetTop(&amp;S2,&amp;a);</span><br><span class="line"><span class="keyword">while</span>(a!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">PushQueue(&amp;L,a);</span><br><span class="line">C=a;</span><br><span class="line">GetTop(&amp;S2,&amp;a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(L.front-&gt;next!=L.rear)&#123;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">GetQueue(&amp;L,&amp;b);</span><br><span class="line">Push(&amp;S2,C);</span><br><span class="line">Push(&amp;S2,b);</span><br><span class="line">&#125;</span><br><span class="line">Push(&amp;S2,C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//B和A转化</span></span><br><span class="line"><span class="keyword">while</span>(S2.base!=S2.top)&#123;</span><br><span class="line"><span class="type">char</span> n;</span><br><span class="line"><span class="type">char</span> A[<span class="number">4</span>]=<span class="string">&quot;sae&quot;</span>;</span><br><span class="line"><span class="type">char</span> B[<span class="number">9</span>]=<span class="string">&quot;tsaedsae&quot;</span>;</span><br><span class="line">GetTop(&amp;S2,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;n!=<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">Push(&amp;S1,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">Push(&amp;S1,A[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">Push(&amp;S1,B[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">char</span> m;</span><br><span class="line"><span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">GetTop(&amp;S1,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是考察栈和队列，建议画图解决。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验一 进程的建立</title>
      <link href="/2022/05/12/23-19-37/"/>
      <url>/2022/05/12/23-19-37/</url>
      
        <content type="html"><![CDATA[<h2 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h2><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>​     创建两个进程，让子进程读取一个文件，父进程等待子进程读取 完文件后继续执行，实现进程协同工作。进程协同工作就是协调好两个进程，使之安排好先后次序并以此执行，可以用等待函数来实现这一点。当需要等待子进程运行结束 时，可在父进程中调用等待函数。</p><h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">  <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(fpid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fpid==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：我是子进程,id=%d，开始读取文件：\n&quot;</span>,getpid());</span><br><span class="line">   FILE *fp=fopen(<span class="string">&quot;test1file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);    <span class="comment">//定义文件流</span></span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> text[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">while</span> (fgets(text,<span class="number">2000</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">puts</span>(text);   <span class="comment">//输出文件内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：读取文件结束\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：我是父进程id=%d ,我要等待子进程\n&quot;</span>,getpid());</span><br><span class="line">               </span><br><span class="line">   <span class="type">int</span> ret = waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程 已经结束，ret=%d\n&quot;</span>, ret);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="程序简要分析"><a href="#程序简要分析" class="headerlink" title="程序简要分析"></a>程序简要分析</h4><p>​    该程序主要使用了fork()函数创建了子进程，然后让子进程读取文件并输出文件内容，同时父进程等待子进程的执行，这里用到了waitpid()函数。等待子进程运行完成后，父进程继续运行。</p><p>主要函数：pid_t fork(void)</p><p>​      pid_t waitpid(pid_t pid,int * status,int options）</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 上机实验 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,World!</title>
      <link href="/2022/05/12/21-48-48/"/>
      <url>/2022/05/12/21-48-48/</url>
      
        <content type="html"><![CDATA[<p>​       搭建了一晚上，终于完成了博客的搭建，第一篇总得起个好名字吧。想了很久还是叫做“Hello,World”吧，我想对于每个程序员来说搭载好每一个新环境的测试都会是“Hello,World”。</p><p>​       从吴军的《浪潮之巅》中得知，“Hello,World”最早诞生于贝尔实验室，你可能对这个实验室的名字感到陌生，新一轮技术革命的核心——集成电路、Linux操作系统的前身Unix、编程始祖且长久未衰的C语言、卫星电话……全部出自贝尔实验室。包括我们熟知的Intel、AMD等芯片巨头都与这家实验室有着千丝万缕的联系。毫不夸张的说，贝尔实验室创造了现代科技的半壁江山。有谁能想到就是一家起初做电话的公司发展到拥有史上最牛实验室的科技帝国，又有谁能想到时至今日那个诞生过13名诺奖得主的实验室已沦落成为一个平平无奇的研究机构，更无人能想到主宰下一个百年的技术在何方……</p><p>​       这就是这个时代，冷酷，但有情。</p><p>​       “Hello，World”，世界你好，世界很好，世界变得更好！</p>]]></content>
      
      
      <categories>
          
          <category> 发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《浪潮之巅》 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
