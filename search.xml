<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello,World!</title>
    <url>/2022/05/12/21-48-48/</url>
    <content><![CDATA[<p>​       搭建了一晚上，终于完成了博客的搭建，第一篇总得起个好名字吧。想了很久还是叫做“Hello,World”吧，我想对于每个程序员来说搭载好每一个新环境的测试都会是“Hello,World”。</p>
<p>​       从吴军的《浪潮之巅》中得知，“Hello,World”最早诞生于贝尔实验室，你可能对这个实验室的名字感到陌生，新一轮技术革命的核心——集成电路、Linux操作系统的前身Unix、编程始祖且长久未衰的C语言、卫星电话……全部出自贝尔实验室。包括我们熟知的Intel、AMD等芯片巨头都与这家实验室有着千丝万缕的联系。毫不夸张的说，贝尔实验室创造了现代科技的半壁江山。有谁能想到就是一家起初做电话的公司发展到拥有史上最牛实验室的科技帝国，又有谁能想到时至今日那个诞生过13名诺奖得主的实验室已沦落成为一个平平无奇的研究机构，更无人能想到主宰下一个百年的技术在何方……</p>
<p>​       这就是这个时代，冷酷，但有情。</p>
<p>​       “Hello，World”，世界你好，世界很好，世界变得更好！</p>
]]></content>
      <categories>
        <category>发展</category>
      </categories>
      <tags>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
  <entry>
    <title>实验一 进程的建立</title>
    <url>/2022/05/12/23-19-37/</url>
    <content><![CDATA[<h2 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h2><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>​     创建两个进程，让子进程读取一个文件，父进程等待子进程读取 完文件后继续执行，实现进程协同工作。进程协同工作就是协调好两个进程，使之安排好先后次序并以此执行，可以用等待函数来实现这一点。当需要等待子进程运行结束 时，可在父进程中调用等待函数。</p>
<h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">  <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(fpid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fpid==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：我是子进程,id=%d，开始读取文件：\n&quot;</span>,getpid());</span><br><span class="line">   FILE *fp=fopen(<span class="string">&quot;test1file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);    <span class="comment">//定义文件流</span></span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> text[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">while</span> (fgets(text,<span class="number">2000</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">puts</span>(text);   <span class="comment">//输出文件内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：读取文件结束\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：我是父进程id=%d ,我要等待子进程\n&quot;</span>,getpid());</span><br><span class="line">               </span><br><span class="line">   <span class="type">int</span> ret = waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程 已经结束，ret=%d\n&quot;</span>, ret);</span><br><span class="line">   	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="程序简要分析"><a href="#程序简要分析" class="headerlink" title="程序简要分析"></a>程序简要分析</h4><p>​    该程序主要使用了fork()函数创建了子进程，然后让子进程读取文件并输出文件内容，同时父进程等待子进程的执行，这里用到了waitpid()函数。等待子进程运行完成后，父进程继续运行。</p>
<p>主要函数：pid_t fork(void)</p>
<p>​      pid_t waitpid(pid_t pid,int * status,int options）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>上机实验</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>魔王语言解释</title>
    <url>/2022/05/13/17-39-53/</url>
    <content><![CDATA[<p>问题输入<br>一组数据，数据为一个字符串，表示一个待翻译的字符串。<br>问题输出<br>将字符串按规则翻译后输出。<br>输入样例<br>B(pxyzABhij)B<br>输出样例<br>tsaedsaepjpiphptsaedsaepsaepzpypxptsaedsae</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> *base;</span><br><span class="line">	<span class="type">char</span> *top;</span><br><span class="line">	<span class="type">int</span> size; </span><br><span class="line">&#125;sqStack;   </span><br><span class="line"><span class="comment">//构造栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">	S-&gt;base=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*maxsize);</span><br><span class="line">	<span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	S-&gt;size=maxsize;</span><br><span class="line">	S-&gt;top=S-&gt;base;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;top==S-&gt;base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> *c=*--S-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">	*S-&gt;top++=c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">LNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	LNode next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	LNode front;  <span class="comment">//队头指针 </span></span><br><span class="line">	LNode rear;   <span class="comment">//队尾指针 </span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//构造队列 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span>&#123;</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">	Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PushQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">	LNode p=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">	p-&gt;data=c;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear-&gt;next=p;</span><br><span class="line">	Q-&gt;rear=p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   LNode p=Q-&gt;front-&gt;next;</span><br><span class="line">   *c=p-&gt;data;</span><br><span class="line">   Q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==p) Q-&gt;rear=Q-&gt;front;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> st[<span class="number">1000</span>],a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">	<span class="comment">//puts(st);</span></span><br><span class="line">	sqStack S1,S2;</span><br><span class="line">	LinkQueue L;</span><br><span class="line">	InitQueue(&amp;L);</span><br><span class="line">	InitStack(&amp;S1);</span><br><span class="line">	InitStack(&amp;S2);</span><br><span class="line">	<span class="comment">//将字符串从右向左依次入栈 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(<span class="built_in">strlen</span>(st)<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		Push(&amp;S1,st[i]);</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//处理括号内容 </span></span><br><span class="line">	<span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">		<span class="type">char</span> r;</span><br><span class="line">		GetTop(&amp;S1,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(r!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			Push(&amp;S2,r);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="type">char</span> C;</span><br><span class="line">			GetTop(&amp;S2,&amp;a);</span><br><span class="line">			<span class="keyword">while</span>(a!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				PushQueue(&amp;L,a);</span><br><span class="line">				C=a;</span><br><span class="line">				GetTop(&amp;S2,&amp;a);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(L.front-&gt;next!=L.rear)&#123;</span><br><span class="line">				<span class="type">char</span> b;</span><br><span class="line">				GetQueue(&amp;L,&amp;b);</span><br><span class="line">				Push(&amp;S2,C);</span><br><span class="line">				Push(&amp;S2,b);</span><br><span class="line">			&#125;</span><br><span class="line">			Push(&amp;S2,C);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//B和A转化</span></span><br><span class="line">	<span class="keyword">while</span>(S2.base!=S2.top)&#123;</span><br><span class="line">		<span class="type">char</span> n;</span><br><span class="line">		<span class="type">char</span> A[<span class="number">4</span>]=<span class="string">&quot;sae&quot;</span>;</span><br><span class="line">		<span class="type">char</span> B[<span class="number">9</span>]=<span class="string">&quot;tsaedsae&quot;</span>;</span><br><span class="line">		GetTop(&amp;S2,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;n!=<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			Push(&amp;S1,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				Push(&amp;S1,A[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				Push(&amp;S1,B[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">char</span> m;</span><br><span class="line">	<span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">		GetTop(&amp;S1,&amp;m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是考察栈和队列，建议画图解决。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫问题</title>
    <url>/2022/05/13/17-51-40/</url>
    <content><![CDATA[<h3 id="问题输入"><a href="#问题输入" class="headerlink" title="问题输入"></a>问题输入</h3><p>一组数据，输入数据第1行为两个正整数m和n，m表示迷宫高度，n表示迷宫宽度，m&lt;100,n&lt;100；第2行为两个整数，分表表示起点的行列位置；第3为两个整数，分别表示终点的行列位置；其后为m行数据，每行n个整数，表示迷宫对应位置的状态，0表示通路，1表示障碍。 </p>
<h3 id="问题输出"><a href="#问题输出" class="headerlink" title="问题输出"></a>问题输出</h3><p>以三元组形式（见P105）输出从起点到终点搜索到的第一条通路，没有则输出no </p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>8 8</p>
<p>1 1</p>
<p>8 8</p>
<p>0 0 1 0 0 0 1 0</p>
<p>0 0 1 1 0 0 1 0 </p>
<p>0 0 0 0 1 1 0 0</p>
<p>0 1 1 1 0 0 0 0</p>
<p>0 0 0 1 1 0 0 0</p>
<p>0 1 0 0 0 1 0 0</p>
<p>0 1 1 1 0 1 1 0</p>
<p>1 1 0 0 0 0 0 0</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>(1,1,1),(1,2,2),(2,2,2),(3,2,3),(3,1,2),(4,1,2),(5,1,1),(5,2,1),(5,3,2),(6,3,1),(6,4,1),(6,5,2),(7,5,2),(8,5,1),(8,6,1),(8,7,1),(8,8,1) </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> **<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> di;</span><br><span class="line">&#125;seat;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	seat *base;</span><br><span class="line">	seat *top;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;sqStack;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">	S-&gt;base=(seat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seat)*Maxsize);</span><br><span class="line">	<span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	S-&gt;size=Maxsize;</span><br><span class="line">	S-&gt;top=S-&gt;base;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,seat a)</span>&#123;</span><br><span class="line">	*S-&gt;top++=a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,seat *a)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;base==S-&gt;top) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> *a=*--S-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Map</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="built_in">map</span>=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">		<span class="built_in">map</span>[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">	   <span class="built_in">map</span>[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	   <span class="built_in">map</span>[i][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line">		<span class="built_in">map</span>[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[x<span class="number">-1</span>][j]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;y<span class="number">-1</span>;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findPath</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span>&#123;</span><br><span class="line">	sqStack q;</span><br><span class="line">	InitStack(&amp;q);</span><br><span class="line">	seat a,b,c;</span><br><span class="line">	<span class="type">int</span> d,m,n,f;</span><br><span class="line">	a.x=x1;</span><br><span class="line">	a.y=y1;</span><br><span class="line">	<span class="built_in">map</span>[x1][y1]=<span class="number">-1</span>;</span><br><span class="line">	a.di=<span class="number">0</span>;</span><br><span class="line">	Push(&amp;q,a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q.top!=q.base)&#123;</span><br><span class="line">		<span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2) <span class="keyword">break</span>;</span><br><span class="line">		d=(q.top<span class="number">-1</span>)-&gt;di;</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(d&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">            d++;</span><br><span class="line">			<span class="keyword">switch</span>(d)&#123;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">1</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y+<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">2</span>: m=(q.top<span class="number">-1</span>)-&gt;x+<span class="number">1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">3</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y<span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">4</span>: m=(q.top<span class="number">-1</span>)-&gt;x<span class="number">-1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">			  	&#125;	</span><br><span class="line">			  <span class="keyword">if</span>(<span class="built_in">map</span>[m][n]==<span class="number">0</span>)&#123;</span><br><span class="line">			  	<span class="built_in">map</span>[m][n]=<span class="number">-1</span>;</span><br><span class="line">			  	(q.top<span class="number">-1</span>)-&gt;di=d;</span><br><span class="line">			  	b.x=m;</span><br><span class="line">			  	b.y=n;</span><br><span class="line">			  	b.di=<span class="number">0</span>;</span><br><span class="line">			  	Push(&amp;q,b);</span><br><span class="line">			  	f=<span class="number">1</span>;</span><br><span class="line">			  	<span class="keyword">break</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">			GetTop(&amp;q,&amp;c);</span><br><span class="line">			<span class="built_in">map</span>[c.x][c.y]=<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2)&#123;</span><br><span class="line">		<span class="keyword">for</span>(seat *i=q.base;i&lt;(q.top<span class="number">-1</span>);i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d),&quot;</span>,i-&gt;x,i-&gt;y,i-&gt;di);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d)&quot;</span>,(q.top<span class="number">-1</span>)-&gt;x,(q.top<span class="number">-1</span>)-&gt;y,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> X,Y,ax,ay,bx,by;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;X,&amp;Y,&amp;ax,&amp;ay,&amp;bx,&amp;by);</span><br><span class="line">	Map(X+<span class="number">2</span>,Y+<span class="number">2</span>); <span class="comment">//初始化迷宫，把迷宫四周围上1；</span></span><br><span class="line">	findPath(ax,ay,bx,by);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Intel时代</title>
    <url>/2022/05/13/22-40-51/</url>
    <content><![CDATA[<p>​    之所以要写Intel，是因为近日计组课涉及了指令集的内容，就忽然想到了《浪潮之巅》中对Intel的介绍。如果你有读过《浪潮之巅》，那么你没有必要浪费时间阅读这篇关于Intel的介绍，因为这篇介绍的大部分内容在这本书中都包含。如果你没有读过，那么也强烈希望你能在读完这篇介绍后阅读一下这本书，尤其是计算机从业者。</p>
<h3 id="历史必然选择"><a href="#历史必然选择" class="headerlink" title="历史必然选择"></a>历史必然选择</h3><p>​    1968年摩尔和诺伊斯创办了英特尔公司，就是提出摩尔定律（每18个月集成电路复杂度会翻倍，有机会再细讲）的那个男人。起初的英特尔只是一个小婴儿，因为IBM（当时最大的计算机厂商之一）等计算机制造公司都是自己设计处理器，而英特尔设计的都是一些低端的微型处理器。70年代末，英特尔设计出了处理器8086.</p>
<p>​    由于IBM公司当时为了与苹果快速抢占个人计算机（PC）市场，就索性直接采用了英特尔的8086，这一用直接奠定了英特尔的“不可撼动”的地位。原因就是IBM的PC机销售远超预期。之后兼容机（其实就是组装机啦）由于价格低廉也有不错的销量，而这些兼容机毫无疑问必须选择8086处理器和Windows才能实现兼容的目的。所以时至今日，IBM已经不再生产PC，但是英特尔和微软的地位无法撼动。</p>
<p>​    再后来，英特尔也走上了高端路线，设计了奔腾系、酷睿系、牙膏系（狗头）……</p>
<h3 id="指令集的战争"><a href="#指令集的战争" class="headerlink" title="指令集的战争"></a>指令集的战争</h3><p>​    这部分才是这篇想主要介绍的东西，可以作为课程知识的背景。</p>
<p>​    先简要了解一下什么是指令集：就是CPU中用来计算和控制计算机系统的一套指令的集合。再了解一下两大指令集CISC（复杂指令集）和RISC（精简指令集）的区别，来自计组课本：</p>
<ol>
<li><p>指令系统 CISC数量多，复杂；RISC数量少，精简。</p>
</li>
<li><p>使用频率 CISC相差大；RISC 接近。毕竟RISC就是选取了使用频率高的指令。</p>
</li>
<li><p>CUP功耗 CISC高；RISC低。</p>
<p>……</p>
</li>
</ol>
<p>​    简单对比后就算你不知道什么是指令集你也一定会说RISC比较好。那么恭喜你和当时众多学者想法一样，未来将是RISC的天下。<br>​    于是一大堆企业转战RISC，其中包括一些原本只是采购而自己不研发的企业开始自己研发RISC处理器，谁都想在风口上飞起来。英特尔也感受到了危机，但是做出了最正确的选择。英特尔继续坚持自己在基于CISC指令集的CPU上的领先地位，又开始着手RISC指令。之后英特尔开发出来几款RISC产品，但是都不成功。而RISC派这边，基本处于各自为战的状态，群龙无首，做出的机器兼容性可想而知。虽然RISC具有天然的性能优势，但是英特尔已经将自己的CISC优化的非常不错，但是绝大部分消费者在稳定兼容和性能稍稍领先上选择前者。<br>​    这里还有一个小故事，在RISC提出之前。有一家企业可以和英特尔抗衡——摩托罗拉。当时IBM选择了英特尔，而苹果选择了摩托罗拉。但是RISC指令提出后由于摩托罗拉做出了错误的决定再加上管理层问题，丢失了以前的大部分订单，基本上放弃了CISC转战RISC，直到最后一棵稻草苹果也放弃它。<br>​    虽然那个年代的指令集之争英特尔大获全胜，但是新世纪以来，由于智能手机的快速发展，基于ARM架构(采用RISC指令集)的手机处理器也换代发展迅速。当某一架构的硬件性能达到极限时，只能尝试改变，于是最近英特尔也正在进军RISC-V，毕竟RISC具有天然性能优势。</p>
<h3 id="芯片帝国"><a href="#芯片帝国" class="headerlink" title="芯片帝国"></a>芯片帝国</h3><p>​    英特尔毫无疑问已经发展成为了一个芯片帝国，世界上超一半计算机都在采用英特尔芯片。它的成功离不开决策、时机、运气。英特尔历史上唯一的错误决定就是看轻了智能手机时代，将手机芯片拱手相让，错失了一次绝佳良机。现在好似又出现一家看似能和英特尔较量的公司——AMD。但是两者其实根本不在一个水平上，AMD为了抢占英特尔市场也只能跟在英特尔身后做出兼容芯片，起码我们消费者又多了一个非常不错的选择。</p>
<p>​    </p>
]]></content>
      <categories>
        <category>发展</category>
      </categories>
      <tags>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员天花板——雷军</title>
    <url>/2022/05/20/19-46-53/</url>
    <content><![CDATA[<p>​    数码圈流传着这样一句话：“你可以不喜欢小米，但是你没有理由不钦佩雷军”。这位每次出现在大众视野基本都是穿着牛仔裤和衬衫标准”程序员“搭配的”雷布斯“，不仅担任着数家上市公司董事长，还是一位极具前瞻性的天使投资人，已经成为程序员天花板。</p>
<h3 id="“有人说我写的代码-如诗一样优雅”"><a href="#“有人说我写的代码-如诗一样优雅”" class="headerlink" title="“有人说我写的代码 如诗一样优雅”"></a>“有人说我写的代码 如诗一样优雅”</h3><p>​    这句话是雷军在一段访谈中对自己的称赞，作为程序员出身的雷军对自己的编程能力还是蛮自信的，事实究竟如何？有人扒出了一段雷军在1994年写的一段完整的汇编代码贴在了网上，无数网友回复”跪着读完“。这一段高质量的代码就算在今天也少有人能写的出来。</p>
<p>​    1987年雷军进入武汉大学计算机系，他仅使用了两年的时间完成了所有大学内容和毕业设计。大学期间写过的很多代码早已被编入武汉大学的教材……在大学期间他就开始写软件出售来赚取利润。大四那年他开始了人生的第一次创业，仿制金山汉卡。然而他的第一次创业以失败告终，破产清算时仅仅获得了一台电脑。别急，传奇才刚刚开始。</p>
<h3 id="扛起中国软件的大旗——金山"><a href="#扛起中国软件的大旗——金山" class="headerlink" title="扛起中国软件的大旗——金山"></a>扛起中国软件的大旗——金山</h3><p>​    谁也没想到，最初靠仿制金山赚钱的雷军一眼被“中国第一程序员”——求伯君看中，力邀他加入金山，几年的时间内，雷军就从一个新员工成为了金山总裁。当时金山面临的最大对手就是微软，微软的office利用与操作系统捆绑的优势成为后起之秀，抢占了WPS的大部分市场。雷军年少轻狂，带领团队做出了新一代产品”盘古“,里面融合了文字处理、词典、事务管理等多种功能，本想凭借这一产品重回巅峰，但惨淡的销售量给了雷军闷头一棒。</p>
<p>​    这一盆冷水浇得雷军醒不过来，最后他递交了辞职信。但是求伯君极力挽留，只给他休假。半年后，雷军重回岗位，他这次回来显然已经制定好了转型战略，之后新版WPS强势上场，在微软的歼灭战中夹缝生存，重新赢得了不少的市场占有率。</p>
<p>​    直到2007年，金山上市，雷军为这一刻付出了十几年的心血。金山无疑是中国软件的一面旗帜，在遭遇国外产品不公平竞争的时刻依旧逆势而上，并且获得了不菲的成绩！</p>
<h3 id="“所有产品不超过5-的利润”——小米"><a href="#“所有产品不超过5-的利润”——小米" class="headerlink" title="“所有产品不超过5%的利润”——小米"></a>“所有产品不超过5%的利润”——小米</h3><p>​    就在金山上市后两个月，雷军宣布离职，这让很多人不能理解。接下来的时间，雷军开始专注自己的投资事业，同时，雷军似乎拥有感应商业机会的本能，他在等待拥抱一个全新时代的到来——移动互联时代。</p>
<p>​    在iPhone开始风靡全球的同时，他在思考安卓的开放性是不是更具有可玩性。他找到投资人、“同盟者”，向他们描述他大胆的想法。2010年四月，在北京一家小工作室里，十几个人喝了一锅小米粥，小米诞生。</p>
<p>​    2011年，小米第一部手机发布，豪华的配置，1999的价格，赢得了一众好评，出现了一机难求的场面。2013年，红米首款手机发布，以极低的价格终结了山寨机泛滥的市场。</p>
<p>​    2019年，小米成为了世界最年轻的500强，并且具有了完整的生态链体系。</p>
<p>​    如今，雷军已经开启了自己人生的最后一次伟大创业——小米汽车，我们无法预测结果如何，但可以肯定的是雷军早已成为中国科技界的“传奇”！这位向往纯粹技术的工程师在为实现“科技走进千家万户”而努力。</p>
<h4 id="因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛"><a href="#因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛" class="headerlink" title="因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛"></a>因为简单纯粹，所以无所畏惧；因为无所畏惧，所以一往无前！——范海涛</h4><p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>发展</category>
      </categories>
      <tags>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
  <entry>
    <title>实验六 信号量实现进程同步</title>
    <url>/2022/08/28/11-08-08/</url>
    <content><![CDATA[<h2 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h2><h5 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h5><p>  进程同步是操作系统多进程/多线程并发执行的关键之一，进程 同步是并发进程为了完成共同任务采用某个条件来协调他们的活 动，这是进程之间发生的一种直接制约关系。本次试验是利用信号量进行进程同步。</p>
<h5 id="【实验软硬件环境】"><a href="#【实验软硬件环境】" class="headerlink" title="【实验软硬件环境】"></a>【实验软硬件环境】</h5><p> Linux，gcc</p>
<h5 id="【实验内容】"><a href="#【实验内容】" class="headerlink" title="【实验内容】"></a>【实验内容】</h5><p>生产者进程生产产品，消费者进程消费产品。当生产者进程生产产品时，如果没有空缓冲区可用，那么生产者进程必须等待消费者进程释放出一个缓冲区。当消费者进程消费产品时，如果缓冲区中没有产品，那么消费 者进程将被阻塞，直到新的产品被生产出来。</p>
<h5 id="【实验程序及分析】"><a href="#【实验程序及分析】" class="headerlink" title="【实验程序及分析】"></a>【实验程序及分析】</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSEM 5</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> fullid, emptyid,mutxid;   <span class="comment">//f 已有产品量  e 空余量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">P</span>,<span class="title">V</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line">   <span class="comment">//声明共享主存array, sum, get, set</span></span><br><span class="line">   <span class="type">int</span> *<span class="built_in">array</span>;</span><br><span class="line">   <span class="type">int</span> *sum;</span><br><span class="line">   <span class="type">int</span> *get;</span><br><span class="line">   <span class="type">int</span> *<span class="built_in">set</span>;</span><br><span class="line">   <span class="comment">//将array，sum,set,get映射到共享主存</span></span><br><span class="line">   <span class="built_in">array</span> =(<span class="type">int</span> *)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*MAXSEM,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">   sum=(<span class="type">int</span> *)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>),PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>); </span><br><span class="line">   <span class="built_in">set</span>=(<span class="type">int</span> *)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>),PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">   get=(<span class="type">int</span> *)mmap(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>),PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="comment">//创建信号量fullid, emptyid,mutxid</span></span><br><span class="line">   fullid=semget(IPC_PRIVATE,<span class="number">1</span>,IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">   emptyid=semget(IPC_PRIVATE,<span class="number">1</span>,IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">   mutxid=semget(IPC_PRIVATE,<span class="number">1</span>,IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">   <span class="comment">//初始化信号量</span></span><br><span class="line">   arg.val=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(semctl(fullid,<span class="number">0</span>,SETVAL,arg)==<span class="number">-1</span>)perror(<span class="string">&quot;semctl setval error&quot;</span>);</span><br><span class="line">      arg.val=MAXSEM;</span><br><span class="line">   <span class="keyword">if</span>(semctl(emptyid,<span class="number">0</span>,SETVAL,arg)==<span class="number">-1</span>)perror(<span class="string">&quot;semctl setval error&quot;</span>);</span><br><span class="line">      arg.val=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(semctl(mutxid,<span class="number">0</span>,SETVAL,arg)==<span class="number">-1</span>)perror(<span class="string">&quot;semctl setval error&quot;</span>);</span><br><span class="line">   <span class="comment">//初始化P，V操作</span></span><br><span class="line">   V.sem_num=<span class="number">0</span>;</span><br><span class="line">   V.sem_op=<span class="number">1</span>;</span><br><span class="line">   V.sem_flg=SEM_UNDO;</span><br><span class="line">   P.sem_num=<span class="number">0</span>;</span><br><span class="line">   P.sem_op=<span class="number">-1</span>;</span><br><span class="line">   P.sem_flg=SEM_UNDO;</span><br><span class="line">   <span class="comment">//创建生产者进程</span></span><br><span class="line">   <span class="type">pid_t</span> fpid1=fork();</span><br><span class="line">   <span class="keyword">if</span>(fpid1==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;<span class="number">100</span>)&#123;</span><br><span class="line">   <span class="comment">//对emptyid ,mutxid执行P操作</span></span><br><span class="line">   semop(emptyid,&amp;P,<span class="number">1</span>);</span><br><span class="line">   semop(mutxid,&amp;P,<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">array</span>[*(<span class="built_in">set</span>)%MAXSEM] = i+<span class="number">1</span>;   <span class="comment">//生产产品</span></span><br><span class="line">   (*<span class="built_in">set</span>)++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;produce %d\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//对emptyid, mutxid执行V操作</span></span><br><span class="line">   semop(mutxid,&amp;V,<span class="number">1</span>);</span><br><span class="line">   semop(fullid,&amp;V,<span class="number">1</span>);</span><br><span class="line">   i++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//休眠一段时间</span></span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//打印生产者结束</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;producer is over\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//创建消费者进程</span></span><br><span class="line">        <span class="type">pid_t</span> fpid2=fork();</span><br><span class="line">        <span class="keyword">if</span>(fpid2==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">//消费者进程A</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="comment">//对fuild, mutxid执行P操作</span></span><br><span class="line">       semop(fullid,&amp;P,<span class="number">1</span>);</span><br><span class="line">       semop(mutxid,&amp;P,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(*get == <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        *sum += <span class="built_in">array</span>[(*get)%MAXSEM];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the comsumer A get number %d\n&quot;</span>, <span class="built_in">array</span>[(*get)%MAXSEM]);</span><br><span class="line">        (*get) ++;</span><br><span class="line">        <span class="keyword">if</span>(*get == <span class="number">100</span>)</span><br><span class="line">         &#123;<span class="built_in">printf</span>(<span class="string">&quot;the sum is %d\n&quot;</span>, *sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//对emptyid, mutxid执行V操作</span></span><br><span class="line">       semop(mutxid,&amp;V,<span class="number">1</span>);</span><br><span class="line">       semop(emptyid,&amp;V,<span class="number">1</span>);</span><br><span class="line">       sleep(<span class="number">0.5</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;consumer A is over\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//消费者进程B</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="comment">//对fuild, mutxid执行P操作</span></span><br><span class="line">       semop(fullid,&amp;P,<span class="number">1</span>);</span><br><span class="line">       semop(mutxid,&amp;P,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(*get == <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        *sum += <span class="built_in">array</span>[(*get)%MAXSEM];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the comsumer B get number %d\n&quot;</span>, <span class="built_in">array</span>[(*get)%MAXSEM]);</span><br><span class="line">        (*get) ++;</span><br><span class="line">        <span class="keyword">if</span>(*get == <span class="number">100</span>)</span><br><span class="line">        &#123;<span class="built_in">printf</span>(<span class="string">&quot;the sum is %d\n&quot;</span>, *sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//对emptyid, mutxid执行V操作</span></span><br><span class="line">       semop(mutxid,&amp;V,<span class="number">1</span>);</span><br><span class="line">       semop(emptyid,&amp;V,<span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">   &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;consumer B is over\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="【程序分析】："><a href="#【程序分析】：" class="headerlink" title="【程序分析】："></a>【程序分析】：</h5><p>本次实验创建了一个生产者进程和两个消费者进程，主要是通过共享内存机制通过进行PV操作完成，设置了信号量fullid, emptyid,mutxid来实现对生产者，消费者的操作。生产者总共需要生产100个产品，消费者取出产品并进行输出产品编号。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>上机实验</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb QQZone项目架构总结</title>
    <url>/2022/08/28/21-58-21/</url>
    <content><![CDATA[<p>这是学习JavaWeb过程中和以往相比做的比较复杂的小项目，是通过tymeleaf进行渲染的B/S（浏览器/服务器）小项目，课程链接：<a href="https://www.bilibili.com/video/BV1AS4y177xJ?p=1">尚硅谷丨2022版JavaWeb教程(全新技术栈,全程实战)</a>，尚硅谷，yyds!!!<br>由于不想花过多的时间在前端上，所以HTML/CSS/JavaScript页面模板大多直接使用的课程资料，就自己模仿着做了一个添加日志和注册的页面。听视频介绍这个项目的主要目的就是手撕简约版Spring MVC框架，为了后面学习框架相对轻松一点。第一次实现了数据库、后台程序、前端页面的交互，还是很有意思，所以写下来理清自己的思路，为了自己更好的理解，也欢迎大家纠错更正。</p>
<h2 id="一、开发环境："><a href="#一、开发环境：" class="headerlink" title="一、开发环境："></a>一、开发环境：</h2><p>jdk8+MySQL8+tomcat8.5(课程中用的数据库是MySQL5，由于版本不同有些细节不同也耽误了不少时间，下面会提到)</p>
<h2 id="二、流程图："><a href="#二、流程图：" class="headerlink" title="二、流程图："></a>二、流程图：</h2><p><img src="https://img-blog.csdnimg.cn/0f92b0bf7a334e19b558dd11a9016fcb.png#pic_center" alt="在这里插入图片描述"></p>
<h2 id="三、主要模块"><a href="#三、主要模块" class="headerlink" title="三、主要模块"></a>三、主要模块</h2><h3 id="监听器和IOC容器："><a href="#监听器和IOC容器：" class="headerlink" title="监听器和IOC容器："></a>监听器和IOC容器：</h3><p>一旦监听到服务器启动，开始调用BeanFactory创建容器，通过读取配置文件中的标签内容，将后续的Controller类、Service类、DAO类实例化保存。并且建立依赖关系，比如说操作日志相关内容的控制器TopicController里面用到了TopicService，那么直接将刚刚实例化的TopicService赋值到TopicController中，这就是“控制反转”和“依赖注入”。以往我们写程序，一个对象里面需要另一个对象我们就让前者自己直接new出来，但是这样会导致对象依赖和耦合严重，不利于代码维护。为了实现“高内聚，低耦合”的架构，我们现在把创建对象的权利全部交给第三方，即“控制反转”，然后再通过配置文件中的信息进行“依赖注入”，达到解除耦合的目的。</p>
<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet:"></a>DispatcherServlet:</h3><p>作为核心响应调度，它的工作是拦截获取到浏览器的（A.do?opetate=B）请求，通过字符串处理，在IOC容器中查找到处理该A请求的指定Controller类，再通过反射找到B方法，进行方法参数赋值调用方法。</p>
<p>把MVC中的V即“view‘也放在dispatcherServlet中，控制器进行操作后需要给dispatcherServlet返回一个字符串，dispatcherServlet通过该字符串判断下一步工作，是继续调用其他控制器，还是直接返回页面给浏览器。</p>
<h3 id="Controller、Service、DAO："><a href="#Controller、Service、DAO：" class="headerlink" title="Controller、Service、DAO："></a>Controller、Service、DAO：</h3><p>Controller作为控制器提供一些方法供浏览器选择，比如说浏览器端需要执行日志（Topic）添加工作，那需要调用TopicController中的addTopic()方法，再比如需要执行登录操作，当用户点击“登录”按键时浏览器就调用了UserBasicController（UserBasic是用户信息类，登录时需要查询用户信息，所以调用它的Controller）中的login方法。Service就是业务方法，比如说Controller现在整理好了浏览器发来的日志添加内容，需要保存到数据库了，它就调用相应的Service方法，Service再看看有什么需要封装整理的，然后再调用DAO方法，至于DAO就是JDBC中的内容，应该很熟悉了。</p>
<h2 id="四、遇到的主要问题"><a href="#四、遇到的主要问题" class="headerlink" title="四、遇到的主要问题"></a>四、遇到的主要问题</h2><h4 id="1、项目关联包问题"><a href="#1、项目关联包问题" class="headerlink" title="1、项目关联包问题"></a>1、项目关联包问题</h4><p>异常：java.lang.IllegalStateException: 启动子级时出错</p>
<p>注意操作顺序！一定要先关联上lib下的各种驱动包、添加上tomcat、然后再打包成Artifacts进行部署。刚开始就遇到了找不到MySQL驱动器的问题，原因是将新建的项目一开始就打包成了Artifacts，然后再关联，这样的话Artifacts进行部署时里面当然没有我们关联的驱动。出现这样的问题解决很简单，不需要你删除Artifacts后再添加，只需要Project Structer下面的problems就可以解决。</p>
<h4 id="2、类加载器问题"><a href="#2、类加载器问题" class="headerlink" title="2、类加载器问题"></a>2、类加载器问题</h4><p>异常：java.lang.NullPointerException<br>    at java.util.Properties$LineReader.readLine(Properties.java:434)<br>    at java.util.Properties.load0(Properties.java:353)<br>    at java.util.Properties.load(Properties.java:341)</p>
<p>这个问题我解决了好久，抛出的异常就是在获取数据库链接的时候无法读到你的properties配置文件，无法获取链接。就是这一句出了问题：InputStream stream=ClassLoader.getSystemClassLoader().getResourceAsStream(“jdbc.properties”);</p>
<p>于是我做了个单元测试，在idea里面明明可以获取链接，但是到tomcat服务器上就不行。然后我在评论区下发现了一个留言，需要改成：InputStream stream =JDBCUtils.class.getClassLoader().getResourceAsStream(“jdbc.properties”)，我一试果然成功，为什么出现这样的情况呢，说到底是路径问题：</p>
<p>你可以尝试在idea下和在tomcat环境下分别执行以上两句，你会发现在idea下两个得到的路径是相同的，都是当前项目的src下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(JDBCUtils.class.getClassLoader().getResource(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(ClassLoader.getSystemClassLoader().getResource(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/03615e06056d4441bbbc2d0ccd33dd0f.png#pic_center" alt="在这里插入图片描述"><br>但是同样的代码在tomcat调用时：<br><img src="https://img-blog.csdnimg.cn/43bdac75548147a9a3e7ad63d4bebf91.png#pic_center" alt="在这里插入图片描述"></p>
<p>会发现InputStream stream =JDBCUtils.class.getClassLoader().getResourceAsStream(“jdbc.properties”) 调用的路径是artifacts打包后的“src”目录，是正确的。而InputStream stream=ClassLoader.getSystemClassLoader().getResourceAsStream(“jdbc.properties”);得到的是null。</p>
<h4 id="3、LocalDateTime类转化问题"><a href="#3、LocalDateTime类转化问题" class="headerlink" title="3、LocalDateTime类转化问题"></a>3、LocalDateTime类转化问题</h4><p>异常：java.lang.IllegalArgumentException: Can not set java.util.Date field com.guoliang.qqzone.pojo.Topic.topicDate to java.time.LocalDateTime</p>
<p>当调用DAO时一旦发现异常can not set A to B，就是你不能把B类型赋值给A。</p>
<p>视频中老师讲的时候是没有这个问题的，因为老师用的是MySQL5,这个问题应该是MySQL8驱动引入的。该项目数据库中的Date全部是DateTime，对应的Java中是LocalDateTime或者TimeStamp，而我们Java中设定的全部是Date。</p>
<p>解决方法：1、将pojo类中的Date全部转化为LocalDateTime</p>
<p>​                    2、BaseDAO中加上以下代码进行转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LocalDateTime需要转化</span></span><br><span class="line">            <span class="keyword">if</span> (propertyValue.getClass().toString().equals(<span class="string">&quot;class java.time.LocalDateTime&quot;</span>)) &#123;</span><br><span class="line">                propertyValue = Timestamp.valueOf((LocalDateTime) propertyValue);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、tymeleaf渲染问题"><a href="#4、tymeleaf渲染问题" class="headerlink" title="4、tymeleaf渲染问题"></a>4、tymeleaf渲染问题</h4><p>写好的前端页面展示出来发现与我们所想不一样，这个问题老师也遇到了，再上一个项目中老师一直没有发现，但是这个项目老师成功解决了这个问题。问题根源在于既然使用了tymeleaf，你就不能直接调用网页，必须经过DispactureServlet中的视图模块进行调用渲染，否则你页面上的所有“th:”都无法识别。</p>
<h2 id="六、部分结果展示："><a href="#六、部分结果展示：" class="headerlink" title="六、部分结果展示："></a>六、部分结果展示：</h2><p><img src="https://img-blog.csdnimg.cn/578830b8768e4587984ac241200b909b.png#pic_center" alt="登录"><br><img src="https://img-blog.csdnimg.cn/65a6f68cbe8f4e43a2beed5ff4b3bb94.png#pic_center" alt="主页面"><br><img src="https://img-blog.csdnimg.cn/1ec1501953a745419a283053899c3f23.png#pic_center" alt="回复"><br><img src="https://img-blog.csdnimg.cn/f2f6a93c0e3045a9a556fd1d1055301d.png#pic_center" alt="添加日志"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
</search>
