<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello,World!</title>
    <url>/2022/05/12/21-48-48/</url>
    <content><![CDATA[<p>​       搭建了一晚上，终于完成了博客的搭建，第一篇总得起个好名字吧。想了很久还是叫做“Hello,World”吧，我想对于每个程序员来说搭载好每一个新环境的测试都会是“Hello,World”。</p>
<p>​       从吴军的《浪潮之巅》中得知，“Hello,World”最早诞生于贝尔实验室，你可能对这个实验室的名字感到陌生，新一轮技术革命的核心——集成电路、Linux操作系统的前身Unix、编程始祖且长久未衰的C语言、卫星电话……全部出自贝尔实验室。包括我们熟知的Intel、AMD等芯片巨头都与这家实验室有着千丝万缕的联系。毫不夸张的说，贝尔实验室创造了现代科技的半壁江山。有谁能想到就是一家起初做电话的公司发展到拥有史上最牛实验室的科技帝国，又有谁能想到时至今日那个诞生过13名诺奖得主的实验室已沦落成为一个平平无奇的研究机构，更无人能想到主宰下一个百年的技术在何方……</p>
<p>​       这就是这个时代，冷酷，但有情。</p>
<p>​       “Hello，World”，世界你好，世界很好，世界变得更好！</p>
]]></content>
      <categories>
        <category>随写</category>
      </categories>
      <tags>
        <tag>时代</tag>
        <tag>《浪潮之巅》</tag>
      </tags>
  </entry>
  <entry>
    <title>实验一 进程的建立</title>
    <url>/2022/05/12/23-19-37/</url>
    <content><![CDATA[<h2 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h2><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>​     创建两个进程，让子进程读取一个文件，父进程等待子进程读取 完文件后继续执行，实现进程协同工作。进程协同工作就是协调好两个进程，使之安排好先后次序并以此执行，可以用等待函数来实现这一点。当需要等待子进程运行结束 时，可在父进程中调用等待函数。</p>
<h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> fpid=fork();</span><br><span class="line">  <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(fpid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fpid==<span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：我是子进程,id=%d，开始读取文件：\n&quot;</span>,getpid());</span><br><span class="line">   FILE *fp=fopen(<span class="string">&quot;test1file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);    <span class="comment">//定义文件流</span></span><br><span class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> text[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">while</span> (fgets(text,<span class="number">2000</span>,fp)!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">puts</span>(text);   <span class="comment">//输出文件内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;子进程：读取文件结束\n&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：我是父进程id=%d ,我要等待子进程\n&quot;</span>,getpid());</span><br><span class="line">               </span><br><span class="line">   <span class="type">int</span> ret = waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;父进程：子进程 已经结束，ret=%d\n&quot;</span>, ret);</span><br><span class="line">   	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="程序简要分析"><a href="#程序简要分析" class="headerlink" title="程序简要分析"></a>程序简要分析</h4><p>​    该程序主要使用了fork()函数创建了子进程，然后让子进程读取文件并输出文件内容，同时父进程等待子进程的执行，这里用到了waitpid()函数。等待子进程运行完成后，父进程继续运行。</p>
<p>主要函数：pid_t fork(void)</p>
<p>​      pid_t waitpid(pid_t pid,int * status,int options）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>上机实验</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>魔王语言解释</title>
    <url>/2022/05/13/17-39-53/</url>
    <content><![CDATA[<p>问题输入<br>一组数据，数据为一个字符串，表示一个待翻译的字符串。<br>问题输出<br>将字符串按规则翻译后输出。<br>输入样例<br>B(pxyzABhij)B<br>输出样例<br>tsaedsaepjpiphptsaedsaepsaepzpypxptsaedsae</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> *base;</span><br><span class="line">	<span class="type">char</span> *top;</span><br><span class="line">	<span class="type">int</span> size; </span><br><span class="line">&#125;sqStack;   </span><br><span class="line"><span class="comment">//构造栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">	S-&gt;base=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*maxsize);</span><br><span class="line">	<span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	S-&gt;size=maxsize;</span><br><span class="line">	S-&gt;top=S-&gt;base;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;top==S-&gt;base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> *c=*--S-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">	*S-&gt;top++=c;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">LNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	LNode next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	LNode front;  <span class="comment">//队头指针 </span></span><br><span class="line">	LNode rear;   <span class="comment">//队尾指针 </span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">//构造队列 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span>&#123;</span><br><span class="line">	Q-&gt;front=Q-&gt;rear=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">	Q-&gt;front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PushQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">	LNode p=(LNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QNode));</span><br><span class="line">	p-&gt;data=c;</span><br><span class="line">	p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear-&gt;next=p;</span><br><span class="line">	Q-&gt;rear=p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetQueue</span><span class="params">(LinkQueue *Q,<span class="type">char</span> *c)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==Q-&gt;front) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   LNode p=Q-&gt;front-&gt;next;</span><br><span class="line">   *c=p-&gt;data;</span><br><span class="line">   Q-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;rear==p) Q-&gt;rear=Q-&gt;front;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> st[<span class="number">1000</span>],a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">	<span class="comment">//puts(st);</span></span><br><span class="line">	sqStack S1,S2;</span><br><span class="line">	LinkQueue L;</span><br><span class="line">	InitQueue(&amp;L);</span><br><span class="line">	InitStack(&amp;S1);</span><br><span class="line">	InitStack(&amp;S2);</span><br><span class="line">	<span class="comment">//将字符串从右向左依次入栈 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(<span class="built_in">strlen</span>(st)<span class="number">-1</span>);i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		Push(&amp;S1,st[i]);</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//处理括号内容 </span></span><br><span class="line">	<span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">		<span class="type">char</span> r;</span><br><span class="line">		GetTop(&amp;S1,&amp;r);</span><br><span class="line">		<span class="keyword">if</span>(r!=<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			Push(&amp;S2,r);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(r==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="type">char</span> C;</span><br><span class="line">			GetTop(&amp;S2,&amp;a);</span><br><span class="line">			<span class="keyword">while</span>(a!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				PushQueue(&amp;L,a);</span><br><span class="line">				C=a;</span><br><span class="line">				GetTop(&amp;S2,&amp;a);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(L.front-&gt;next!=L.rear)&#123;</span><br><span class="line">				<span class="type">char</span> b;</span><br><span class="line">				GetQueue(&amp;L,&amp;b);</span><br><span class="line">				Push(&amp;S2,C);</span><br><span class="line">				Push(&amp;S2,b);</span><br><span class="line">			&#125;</span><br><span class="line">			Push(&amp;S2,C);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//B和A转化</span></span><br><span class="line">	<span class="keyword">while</span>(S2.base!=S2.top)&#123;</span><br><span class="line">		<span class="type">char</span> n;</span><br><span class="line">		<span class="type">char</span> A[<span class="number">4</span>]=<span class="string">&quot;sae&quot;</span>;</span><br><span class="line">		<span class="type">char</span> B[<span class="number">9</span>]=<span class="string">&quot;tsaedsae&quot;</span>;</span><br><span class="line">		GetTop(&amp;S2,&amp;n);</span><br><span class="line">		<span class="keyword">if</span>(n!=<span class="string">&#x27;A&#x27;</span>&amp;&amp;n!=<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			Push(&amp;S1,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				Push(&amp;S1,A[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">				Push(&amp;S1,B[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="type">char</span> m;</span><br><span class="line">	<span class="keyword">while</span>(S1.base!=S1.top)&#123;</span><br><span class="line">		GetTop(&amp;S1,&amp;m);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是考察栈和队列，建议画图解决。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>迷宫问题</title>
    <url>/2022/05/13/17-51-40/</url>
    <content><![CDATA[<h3 id="问题输入"><a href="#问题输入" class="headerlink" title="问题输入"></a>问题输入</h3><p>一组数据，输入数据第1行为两个正整数m和n，m表示迷宫高度，n表示迷宫宽度，m&lt;100,n&lt;100；第2行为两个整数，分表表示起点的行列位置；第3为两个整数，分别表示终点的行列位置；其后为m行数据，每行n个整数，表示迷宫对应位置的状态，0表示通路，1表示障碍。 </p>
<h3 id="问题输出"><a href="#问题输出" class="headerlink" title="问题输出"></a>问题输出</h3><p>以三元组形式（见P105）输出从起点到终点搜索到的第一条通路，没有则输出no </p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>8 8</p>
<p>1 1</p>
<p>8 8</p>
<p>0 0 1 0 0 0 1 0</p>
<p>0 0 1 1 0 0 1 0 </p>
<p>0 0 0 0 1 1 0 0</p>
<p>0 1 1 1 0 0 0 0</p>
<p>0 0 0 1 1 0 0 0</p>
<p>0 1 0 0 0 1 0 0</p>
<p>0 1 1 1 0 1 1 0</p>
<p>1 1 0 0 0 0 0 0</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>(1,1,1),(1,2,2),(2,2,2),(3,2,3),(3,1,2),(4,1,2),(5,1,1),(5,2,1),(5,3,2),(6,3,1),(6,4,1),(6,5,2),(7,5,2),(8,5,1),(8,6,1),(8,7,1),(8,8,1) </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10000</span></span><br><span class="line"><span class="type">int</span> **<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="type">int</span> di;</span><br><span class="line">&#125;seat;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	seat *base;</span><br><span class="line">	seat *top;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">&#125;sqStack;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">InitStack</span><span class="params">(sqStack *S)</span>&#123;</span><br><span class="line">	S-&gt;base=(seat *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seat)*Maxsize);</span><br><span class="line">	<span class="keyword">if</span>(!S-&gt;base) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	S-&gt;size=Maxsize;</span><br><span class="line">	S-&gt;top=S-&gt;base;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Push</span><span class="params">(sqStack *S,seat a)</span>&#123;</span><br><span class="line">	*S-&gt;top++=a;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(sqStack *S,seat *a)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;base==S-&gt;top) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> *a=*--S-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Map</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">	<span class="built_in">map</span>=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">		<span class="built_in">map</span>[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">	   <span class="built_in">map</span>[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	   <span class="built_in">map</span>[i][y<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line">		<span class="built_in">map</span>[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">map</span>[x<span class="number">-1</span>][j]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;x<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;y<span class="number">-1</span>;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findPath</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span>&#123;</span><br><span class="line">	sqStack q;</span><br><span class="line">	InitStack(&amp;q);</span><br><span class="line">	seat a,b,c;</span><br><span class="line">	<span class="type">int</span> d,m,n,f;</span><br><span class="line">	a.x=x1;</span><br><span class="line">	a.y=y1;</span><br><span class="line">	<span class="built_in">map</span>[x1][y1]=<span class="number">-1</span>;</span><br><span class="line">	a.di=<span class="number">0</span>;</span><br><span class="line">	Push(&amp;q,a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(q.top!=q.base)&#123;</span><br><span class="line">		<span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2) <span class="keyword">break</span>;</span><br><span class="line">		d=(q.top<span class="number">-1</span>)-&gt;di;</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(d&lt;=<span class="number">4</span>)&#123;</span><br><span class="line">            d++;</span><br><span class="line">			<span class="keyword">switch</span>(d)&#123;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">1</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y+<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">2</span>: m=(q.top<span class="number">-1</span>)-&gt;x+<span class="number">1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">3</span>: m=(q.top<span class="number">-1</span>)-&gt;x; n=(q.top<span class="number">-1</span>)-&gt;y<span class="number">-1</span>; <span class="keyword">break</span>;</span><br><span class="line">			  <span class="keyword">case</span> <span class="number">4</span>: m=(q.top<span class="number">-1</span>)-&gt;x<span class="number">-1</span>; n=(q.top<span class="number">-1</span>)-&gt;y; <span class="keyword">break</span>;</span><br><span class="line">			  	&#125;	</span><br><span class="line">			  <span class="keyword">if</span>(<span class="built_in">map</span>[m][n]==<span class="number">0</span>)&#123;</span><br><span class="line">			  	<span class="built_in">map</span>[m][n]=<span class="number">-1</span>;</span><br><span class="line">			  	(q.top<span class="number">-1</span>)-&gt;di=d;</span><br><span class="line">			  	b.x=m;</span><br><span class="line">			  	b.y=n;</span><br><span class="line">			  	b.di=<span class="number">0</span>;</span><br><span class="line">			  	Push(&amp;q,b);</span><br><span class="line">			  	f=<span class="number">1</span>;</span><br><span class="line">			  	<span class="keyword">break</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">			GetTop(&amp;q,&amp;c);</span><br><span class="line">			<span class="built_in">map</span>[c.x][c.y]=<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((q.top<span class="number">-1</span>)-&gt;x==x2&amp;&amp;(q.top<span class="number">-1</span>)-&gt;y==y2)&#123;</span><br><span class="line">		<span class="keyword">for</span>(seat *i=q.base;i&lt;(q.top<span class="number">-1</span>);i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d),&quot;</span>,i-&gt;x,i-&gt;y,i-&gt;di);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;(%d,%d,%d)&quot;</span>,(q.top<span class="number">-1</span>)-&gt;x,(q.top<span class="number">-1</span>)-&gt;y,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> X,Y,ax,ay,bx,by;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d %d&quot;</span>,&amp;X,&amp;Y,&amp;ax,&amp;ay,&amp;bx,&amp;by);</span><br><span class="line">	Map(X+<span class="number">2</span>,Y+<span class="number">2</span>); <span class="comment">//初始化迷宫，把迷宫四周围上1；</span></span><br><span class="line">	findPath(ax,ay,bx,by);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
</search>
